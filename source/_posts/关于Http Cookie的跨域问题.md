---
title: 关于Http Cookie的跨域问题
date: 2017-04-22 15:20:46
tags: 跨域,cookie
---

## 问题

最近接了新的活动需求，很多流程虽然与原项目一样，但是原项目代码已经不容易维护了，所以合计了一下，单独拿出来重新写一遍，项目目录结构、类库选用了最近做的活动项目模板。终于完善好了整个项目结构，写好了页面开始写业务逻辑了。 然而，就在调通了登录接口之后，发现不管调啥接口，全部都返回“用户未登录的状态”。 

现在的开发环境，域名是localhost:8181，这里的路径是本地页面的文件夹路径；nginx配置了反向代理，通过反向代理访问测试环境的后台接口，域名是类似这样的：https://stg1.test.com。

同样在本地开发，代理到测试环境后台接口，域名和后台接口域名都一样，原来的页面就可以，但是现在服务器就无法维持用户的登录状态了。

这时候就想到服务器要维持用户登录状态，需要通过sessionid这个标识，来看看现在的情况，确实这个会话标识变掉了。以下为模拟实验截图：


接口1-（登录接口）的Cookies信息
![43](/img/关于Http Cookie的跨域问题/1.png)

 “接口2的Cookies信息”
![43](/img/关于Http Cookie的跨域问题/2.png)

现在的JSSESSIONID两个接口返回的不一致。 再开看看原页面的访问情况对比一下，看看哪里不一样了。果然，response cookies两种情况下都有返回，但是发现，原来页面先进行登录，访问接口2时，requst cookies带上了信息。而重写的页面的XHR对象中就没有。

"原页面的Cookies信息"
![43](/img/关于Http Cookie的跨域问题/3.png)

然后问题就来了，看起来明明是一样的接口调用，重写的页面不能保持登录状态，而对比之前页面，唯一的不同就是接口2调用时，Request Cookies里面没有值。 那这个值到底是怎么来的，搞清楚这个问题应该就可以解决了。


### 问题的解决方法

### Request Coolkies 的来历
要弄清楚这个问题，还是要从浏览器与服务器二者之间的通信说起。浏览器需要从服务器拿数据，需要通过ajax请求来实现。我们可以在调试工具中观察调用接口信息时，这个Request Cookies 和 Response Cookies是放在XHR这个对象里的。 这个东东的全称就是XmlHttpRequest，ajax中最最重要的东西就是它了。可以这样创建它：

 	variable = new XMLHttpRequest();
 	
 
